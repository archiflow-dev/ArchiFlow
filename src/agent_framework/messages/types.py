"""
Message Type System for Agent Framework.

Defines all message types used in agent-broker communication.
"""
from dataclasses import dataclass, field, asdict
from typing import Optional, Dict, Any, List
from abc import ABC
import time
import uuid


@dataclass
class BaseMessage(ABC):
    """Base class for all agent framework messages."""
    session_id: str
    sequence: int
    timestamp: float = field(default_factory=time.time)
    message_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    source: str = ""
    actionable: bool = False
    
    
    @property
    def type(self) -> str:
        """Return the message type name."""
        return self.__class__.__name__
    
    def to_dict(self) -> Dict[str, Any]:
        """Serialize message to dictionary."""
        data = asdict(self)
        data['type'] = self.type
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]):
        """Deserialize message from dictionary."""
        # Remove type field if present
        data = {k: v for k, v in data.items() if k != 'type'}
        return cls(**data)


# Input Messages

@dataclass
class UserMessage(BaseMessage):
    """Message from user input."""
    content: str = ""
    source: str = "user"


@dataclass
class SystemMessage(BaseMessage):
    """System-level instructions or state changes."""
    content: str = ""


@dataclass
class EnvironmentMessage(BaseMessage):
    """Events generated by the environment."""
    event_type: str = ""  # "file_changed", "timer_elapsed", etc.
    content: Any = None
    source: str = "environment"


# Agent/LLM Messages

@dataclass
class LLMThinkMessage(BaseMessage):
    """Internal LLM thought process (Chain-of-Thought)."""
    content: str = ""


@dataclass
class LLMRespondMessage(BaseMessage):
    """Final response to the user."""
    content: str = ""


@dataclass
class ToolCall:
    """Represents a single tool call."""
    id: str
    tool_name: str
    arguments: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "tool_name": self.tool_name,
            "arguments": self.arguments
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]):
        return cls(**data)


@dataclass
class ToolCallMessage(BaseMessage):
    """Request to execute a tool."""
    thought: str = ""
    tool_calls: List[ToolCall] = field(default_factory=list)
    actionable: bool = True
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data['tool_calls'] = [tc.to_dict() for tc in self.tool_calls]
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]):
        tool_calls_data = data.pop('tool_calls', [])
        msg = super().from_dict(data)
        msg.tool_calls = [ToolCall.from_dict(tc) for tc in tool_calls_data]
        return msg


# Observation Messages

@dataclass
class ToolResultObservation(BaseMessage):
    """Result of a tool execution."""
    call_id: str = ""
    content: str = ""
    status: str = "success"  # "success" or "error"


@dataclass
class BatchToolResultObservation(BaseMessage):
    """Aggregated result of a batch tool execution."""
    batch_id: str = ""
    results: List[ToolResultObservation] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        data = super().to_dict()
        data['results'] = [r.to_dict() for r in self.results]
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]):
        results_data = data.pop('results', [])
        msg = super().from_dict(data)
        msg.results = [ToolResultObservation.from_dict(r) for r in results_data]
        return msg


@dataclass
class ErrorObservation(BaseMessage):
    """System or tool error."""
    content: str = ""
    traceback: Optional[str] = None


# Control Messages

@dataclass
class WaitForUserInput(BaseMessage):
    """Signal to wait for user input."""
    reason: str = "Waiting for user input"

@dataclass
class StopMessage(BaseMessage):
    """Signal to terminate the agent loop."""
    reason: str = "User requested stop"

@dataclass
class AgentFinishedMessage(BaseMessage):
    """Signal to terminate the agent loop."""
    reason: str = "Agent finished"

# Message type registry for deserialization
MESSAGE_TYPES = {
    'UserMessage': UserMessage,
    'SystemMessage': SystemMessage,
    'EnvironmentMessage': EnvironmentMessage,
    'LLMThinkMessage': LLMThinkMessage,
    'LLMRespondMessage': LLMRespondMessage,
    'ToolCallMessage': ToolCallMessage,
    'ToolResultObservation': ToolResultObservation,
    'BatchToolResultObservation': BatchToolResultObservation,
    'ErrorObservation': ErrorObservation,
    'StopMessage': StopMessage,
    'AgentFinishedMessage': AgentFinishedMessage,
    'WaitForUserInput': WaitForUserInput,
}


def deserialize_message(data: Dict[str, Any]) -> BaseMessage:
    """Deserialize a message from dictionary."""
    msg_type = data.get('type')
    if not msg_type:
        raise ValueError("Message data missing 'type' field")
    
    msg_class = MESSAGE_TYPES.get(msg_type)
    if not msg_class:
        raise ValueError(f"Unknown message type: {msg_type}")
    
    return msg_class.from_dict(data)
